//
// Created by Benjam on 10/29/2021.
//

#include "BasicShaders.h"

namespace Math4BG
{
    std::shared_ptr<Shader> CreateBasicShader()
    {
        ShaderProgramSource basicShaderSource {
                true,
                false,
                true,
                "#version 330 core\n"
                "\n"
                "layout(location = 0) in vec3 inPosition;\n"
                "layout(location = 1) in vec3 inColor;\n"
                "layout(location = 2) in vec2 inTextureCoords;\n"
                "layout(location = 3) in vec3 inNormal;\n"
                "\n"
                "out vec3 vsPosition;\n"
                "out vec3 vsColor;\n"
                "out vec2 vsTextureCoords;\n"
                "out vec3 vsNormal;\n"
                "\n"
                "uniform mat4 ProjectionMatrix;\n"
                "uniform mat4 ViewMatrix;\n"
                "uniform mat4 ModelMatrix;\n"
                "\n"
                "void main()\n"
                "{\n"
                "    vsPosition = vec4(ModelMatrix * vec4(inPosition, 1.0f)).xyz;\n"
                "    vsColor = inColor;\n"
                "    vsTextureCoords = vec2(inTextureCoords.x, inTextureCoords.y * -1.0f);\n"
                "    vsNormal = mat3(ModelMatrix) * inNormal;\n"
                "\n"
                "    gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix * vec4(inPosition, 1.0f);\n"
                "}\n",
                "",
                "#version 330 core\n"
                "\n"
                "#define MAX_POINT_LIGHTS        (10)\n"
                "\n"
                "struct DirectionalLight\n"
                "{\n"
                "    vec4 Color;\n"
                "    vec3 Direction;\n"
                "    float Intensity;\n"
                "};\n"
                "\n"
                "uniform DirectionalLight sDirectionalLight;\n"
                "\n"
                "struct PointLight\n"
                "{\n"
                "    vec3 Position;\n"
                "    float Intensity;\n"
                "    vec4 Color;\n"
                "\n"
                "    float Constant;\n"
                "    float Linear;\n"
                "    float Quadratic;\n"
                "};\n"
                "\n"
                "layout(location = 0) out vec4 fsColor;\n"
                "\n"
                "in vec3 vsPosition;\n"
                "in vec3 vsColor;\n"
                "in vec2 vsTextureCoords;\n"
                "in vec3 vsNormal;\n"
                "\n"
                "uniform vec2 sPixelSize;\n"
                "uniform PointLight sPointLight;\n"
                "uniform vec4 vColor = vec4(1.0f, 1.0f, 1.0f, 1.0f);\n"
                "uniform sampler2D TextureSampler;\n"
                "uniform int bTextureExists;\n"
                "uniform vec3 vCameraPos = vec3(0.0f, 0.0f, 0.0f);\n"
                "\n"
                "vec3 ProcessAmbiant()\n"
                "{\n"
                "    return vec3(0.1f);\n"
                "}\n"
                "\n"
                "vec3 ProcessDiffuse(vec3 pos, vec3 normal, vec3 lightPos0)\n"
                "{\n"
                "    vec3 posToLightDelta = normalize(lightPos0 - pos);\n"
                "    float cosTheta = clamp(dot(posToLightDelta, normalize(normal)), 0, 1);\n"
                "\n"
                "    return vec3(1.0f) * cosTheta;\n"
                "}\n"
                "\n"
                "vec3 ProcessSpecular(vec3 pos, vec3 normal, vec3 lightPos0, vec3 cameraPos)\n"
                "{\n"
                "    vec3 lightToPosDelta = normalize(pos - lightPos0);\n"
                "    vec3 reflectionDirection = normalize(reflect(lightToPosDelta, normalize(normal)));\n"
                "    vec3 posToViewDelta = normalize(cameraPos - pos);\n"
                "    float specularConst = pow(max(dot(posToViewDelta, reflectionDirection), 0), 35);\n"
                "\n"
                "    return vec3(1.0f) * specularConst;\n"
                "}\n"
                "\n"
                "vec4 ApplyDirectionalLight(vec4 color)\n"
                "{\n"
                "    float fDiffuseIntensity = max(0.0, dot(normalize(vsNormal), -sDirectionalLight.Direction));\n"
                "    return color * vec4(vsColor, 1.0) * vec4(sDirectionalLight.Color * sDirectionalLight.Intensity * fDiffuseIntensity);\n"
                "}\n"
                "\n"
                "vec3 ApplyPointLight(PointLight light, vec4 color)\n"
                "{\n"
                "    float ambiantStrength = 0.001f;\n"
                "    vec3 ambiant = ambiantStrength * light.Color.rgb;\n"
                "\n"
                "    vec3 norm = normalize(vsNormal);\n"
                "    vec3 lightDir = normalize(light.Position - vsPosition);\n"
                "    float diff = clamp(dot(norm, lightDir), 0, 1);\n"
                "    vec3 diffuse = diff * light.Color.rgb;\n"
                "\n"
                "    float specularStrength = 0.5;\n"
                "    vec3 viewDir = normalize(vCameraPos - vsPosition);\n"
                "\n"
                "    vec3 reflectDir = reflect(-lightDir, norm);\n"
                "    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);\n"
                "    vec3 specular = specularStrength * spec * light.Color.rgb;\n"
                "\n"
                "    return (ambiant + diffuse + specular) * color.rgb;\n"
                "}\n"
                "\n"
                "void main()\n"
                "{\n"
                "    vec4 textureColor = bTextureExists != 0 ? texture(TextureSampler, vsTextureCoords) : vColor;\n"
                "    vec4 color = ApplyDirectionalLight(textureColor);\n"
                "\n"
                "    for(int i = 0; i < 1; i ++)\n"
                "    {\n"
                "        if(sPointLight.Color.a != 0.0)\n"
                "        {\n"
                "            color += vec4(ApplyPointLight(sPointLight, textureColor), 1.0);\n"
                "        }\n"
                "    }\n"
                "\n"
                "    vec3 result = color.rgb;\n"
                "\n"
                "    fsColor = vec4(result, 1.0f);\n"
                "}"
        };

        return Shader::CreateShader(basicShaderSource);
    }
}